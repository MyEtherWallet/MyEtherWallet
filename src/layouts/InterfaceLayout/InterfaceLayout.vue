<template>
  <div class="send-eth-and-tokens">
    <div class="wrap">
      <div>
        <div
          :class="isSidemenuOpen && 'side-nav-open'"
          class="side-nav-background"
          @click="toggleSideMenu;"
        />
        <div :class="isSidemenuOpen && 'side-nav-open'" class="side-nav">
          <interface-side-menu />
        </div>
      </div>
      <div class="contents">
        <div class="tx-contents">
          <div class="mobile-hide">
            <interface-address :address="address" />
          </div>
          <div class="mobile-hide">
            <interface-balance :balance="balance" />
          </div>
          <div class="mobile-hide">
            <interface-network :block-number="blockNumber" />
          </div>
          <router-view
            :tokens-with-balance="tokensWithBalance"
            :get-balance="getBalance"
            :tokens="tokens"
            :highest-gas="highestGas"
          />
          <div v-if="online" class="tokens">
            <interface-tokens
              :get-token-balance="getTokenBalance"
              :tokens="tokens"
              :received-tokens="receivedTokens"
            />
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { mapGetters } from 'vuex';
import ENS from 'ethereum-ens';

import InterfaceAddress from './components/InterfaceAddress';
import InterfaceBalance from './components/InterfaceBalance';
import InterfaceNetwork from './components/InterfaceNetwork';
import InterfaceSideMenu from './components/InterfaceSideMenu';
import InterfaceTokens from './components/InterfaceTokens';
import { Web3Wallet } from '@/wallets/software';
import * as networkTypes from '@/networks/types';
import { BigNumber } from 'bignumber.js';
import store from 'store';
import TokenBalance from '@myetherwallet/eth-token-balance';

export default {
  components: {
    'interface-side-menu': InterfaceSideMenu,
    'interface-address': InterfaceAddress,
    'interface-balance': InterfaceBalance,
    'interface-network': InterfaceNetwork,
    'interface-tokens': InterfaceTokens
  },
  data() {
    return {
      balance: '0',
      blockNumber: 0,
      tokens: [],
      receivedTokens: false,
      tokensWithBalance: [],
      pollNetwork: () => {},
      pollBlock: () => {},
      pollAddress: () => {},
      highestGas: 0
    };
  },
  computed: {
    isSidemenuOpen() {
      return this.sidemenuOpen;
    },
    address() {
      if (this.wallet !== null) {
        return this.wallet.getChecksumAddressString();
      }
    },
    ...mapGetters({
      network: 'network',
      wallet: 'wallet',
      online: 'online',
      web3: 'web3',
      Networks: 'Networks',
      sidemenuOpen: 'sidemenuOpen'
    })
  },
  watch: {
    network() {
      this.setupOnlineEnvironment();
    },
    address() {
      this.setupOnlineEnvironment();
    }
  },
  mounted() {
    this.setupOnlineEnvironment();
  },
  destroyed() {
    this.clearIntervals();
  },
  methods: {
    toggleSideMenu() {
      this.$store.commit('TOGGLE_SIDEMENU');
    },
    async fetchTokens() {
      this.receivedTokens = true;
      const tb = new TokenBalance(this.web3.currentProvider);
      let tokens = [];
      try {
        tokens = await tb.getBalance(this.wallet.getChecksumAddressString());
      } catch (e) {
        console.error(e);
      }
      return tokens;
    },
    async setNonce() {
      const nonce = await this.web3.eth.getTransactionCount(
        this.wallet.getAddressString()
      );
      store.set(this.web3.utils.sha3(this.wallet.getAddressString()), {
        nonce: nonce,
        timestamp: +new Date()
      });
    },
    async getTokenBalance(token) {
      const web3 = this.web3;
      const contractAbi = [
        {
          name: 'balanceOf',
          type: 'function',
          constant: true,
          inputs: [{ name: 'address', type: 'address' }],
          outputs: [{ name: 'out', type: 'uint256' }]
        }
      ];
      const contract = new web3.eth.Contract(contractAbi);
      const data = contract.methods
        .balanceOf(this.wallet.getAddressString())
        .encodeABI();
      const balance = await web3.eth
        .call({
          to: token.address
            ? web3.utils.toChecksumAddress(token.address)
            : web3.utils.toChecksumAddress(token.addr),
          data: data
        })
        .then(res => {
          let tokenBalance;
          if (Number(res) === 0 || res === '0x') {
            tokenBalance = 0;
          } else {
            const denominator = web3.utils
              .toBN(10)
              .pow(web3.utils.toBN(token.decimals));
            tokenBalance = web3.utils
              .toBN(res)
              .div(denominator)
              .toString(10);
          }
          return tokenBalance;
        })
        .catch(err => {
          // eslint-disable-next-line no-console
          console.error(err);
        });
      return balance;
    },
    async setTokens() {
      if (this.network.type.chainID === 1 || this.network.type.chainID === 3) {
        this.receivedTokens = false;
        const hex = await this.fetchTokens();
        hex
          .sort((a, b) => {
            if (a.name.toUpperCase() < b.name.toUpperCase()) {
              return -1;
            } else if (a.name.toUpperCase() > b.name.toUpperCase()) {
              return 1;
            }
            return 0;
          })
          .map(token => {
            const balance = new BigNumber(token.balance);
            const convertedToken = {
              addr: token.addr,
              balance: balance
                .div(new BigNumber(10).pow(token.decimals))
                .toString(),
              decimals: token.decimals,
              email: token.email,
              name: token.name,
              symbol: token.symbol,
              website: token.website
            };
            return convertedToken;
          });
        this.tokens = hex;
      } else {
        const tokenWithBalance = [];
        this.network.type.tokens.map(async token => {
          token.balance = await this.getTokenBalance(token);
          tokenWithBalance.push(token);
        });
        this.receivedTokens = false;
        this.tokens = tokenWithBalance;
      }

      let customTokens = [];
      if (
        store.get('customTokens') !== undefined &&
        store.get('customTokens')[this.network.type.name] !== undefined &&
        store.get('customTokens')[this.network.type.name].length > 0
      ) {
        customTokens = store.get('customTokens')[
          // eslint-disable-next-line
          this.network.type.name
        ].filter(token => token.balance > 0);
      }
      const allTokens = this.tokens
        .filter(token => token.balance > 0)
        .concat(customTokens);
      this.tokensWithBalance = allTokens;
    },
    getBlock() {
      this.web3.eth
        .getBlockNumber()
        .then(res => {
          this.blockNumber = res;
        })
        .catch(err => {
          // eslint-disable-next-line no-console
          console.error(err);
        });
    },
    getBalance() {
      const web3 = this.web3;
      web3.eth
        .getBalance(this.address)
        .then(res => {
          this.balance = web3.utils.fromWei(res, 'ether');
          this.$store.dispatch('setAccountBalance', this.balance);
        })
        .catch(err => {
          // eslint-disable-next-line no-console
          console.error(err);
        });
    },
    checkWeb3WalletAddrChange() {
      this.pollAddress = setInterval(() => {
        window.web3.eth.getAccounts((err, accounts) => {
          if (err) {
            // eslint-disable-next-line no-console
            console.error(err);
            return;
          }
          if (!accounts.length) {
            // eslint-disable-next-line no-console
            console.error('Please unlock metamask');
            return;
          }
          const address = accounts[0];
          if (
            this.wallet !== null &&
            address !== this.wallet.getAddressString()
          ) {
            const wallet = new Web3Wallet(address);
            this.$store.dispatch('setWeb3Wallet', wallet);
            clearInterval(this.pollAddress);
          }
        });
      }, 500);
    },
    matchWeb3WalletNetwork() {
      this.pollNetwork = setInterval(() => {
        window.web3.version.getNetwork((err, netId) => {
          if (err) return;
          if (this.network.type.chainID.toString() !== netId) {
            Object.keys(networkTypes).forEach(net => {
              if (networkTypes[net].chainID.toString() === netId) {
                this.$store.dispatch('switchNetwork', this.Networks[net][0]);
                clearInterval(this.pollNetwork);
              }
            });
          }
        });
      }, 500);
    },
    clearIntervals() {
      const self = this;
      if (self.wallet === null) {
        clearInterval(self.pollNetwork);
        clearInterval(self.pollBlock);
        clearInterval(self.pollAddress);
      }
    },
    setupOnlineEnvironment() {
      if (this.online === true) {
        if (this.wallet !== null) {
          if (this.wallet.identifier === 'Web3') {
            this.checkWeb3WalletAddrChange();
            this.matchWeb3WalletNetwork();
          }
          this.getBalance();
          this.pollBlock = setInterval(this.getBlock, 14000);
          this.setTokens();
          this.setENS();
          this.setNonce();
          this.getHighestGas();
        }
      }
    },
    getHighestGas() {
      this.web3.eth
        .getGasPrice()
        .then(res => {
          this.highestGas = new BigNumber(
            this.web3.utils.fromWei(res, 'gwei')
          ).toNumber();
        })
        .catch(err => {
          console.error(err);
        });
    },
    setENS() {
      if (this.wallet.identifier === 'Web3') {
        this.$store.dispatch('setENS', new ENS(window.web3.currentProvider));
      } else {
        this.$store.dispatch('setENS', new ENS(this.web3.currentProvider));
      }
    }
  }
};
</script>

<style lang="scss" scoped>
@import 'InterfaceLayout-desktop.scss';
@import 'InterfaceLayout-tablet.scss';
@import 'InterfaceLayout-mobile.scss';
</style>
